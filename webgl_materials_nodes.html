<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Verge3D webgl - node material</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #fff;
        font-family:Monospace;
        font-size:13px;
        margin: 0px;
        text-align:center;
        overflow: hidden;
      }

      #info {
        color: #fff;
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        display:block;
      }

      a { color: white }
    </style>
  </head>
  <body>

    <div id="container"></div>
    <div id="info">
      <a href="https://www.soft8soft.com/verge3d" target="_blank" rel="noopener">Verge3D</a> - Node-Based Material</br>
      <a id="serialize" href="javascript:void(0);">Serialize and apply</a>
    </div>

    <script src="../build/v3d.js"></script>

    <script src='js/geometries/TeapotBufferGeometry.js'></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>

    <script type="module">

      import './js/nodes/v3d.Nodes.js';
      import './js/loaders/NodeMaterialLoader.js';

      var container = document.getElementById('container');

      var renderer, scene, camera, clock = new v3d.Clock(), fov = 50;
      var frame = new v3d.NodeFrame();
      var teapot, mesh;
      var controls;
      var move = false;
      var rtTexture, rtMaterial;
      var gui;
      var library = {};
      var serialized = false;
      var textures = {
        brick: { url: 'textures/brick_diffuse.jpg' },
        grass: { url: 'textures/terrain/grasslight-big.jpg' },
        grassNormal: { url: 'textures/terrain/grasslight-big-nm.jpg' },
        decalDiffuse: { url: 'textures/decal/decal-diffuse.png' },
        decalNormal: { url: 'textures/decal/decal-normal.jpg' },
        cloud: { url: 'textures/lava/cloud.png' },
        spherical: { url: 'textures/envmap.png' }
      };

      var param = { example: new URL(window.location.href).searchParams.get('e') || 'mesh-standard' };

      function getTexture(name) {

        var texture = textures[name].texture;

        if (!texture) {

          texture = textures[name].texture = new v3d.TextureLoader().load(textures[name].url);
          texture.wrapS = texture.wrapT = v3d.RepeatWrapping;

          library[texture.uuid] = texture;

        }

        return texture;

      }

      var cubemap = function() {

        var path = "textures/cube/Park2/";
        var format = '.jpg';
        var urls = [
          path + 'posx' + format, path + 'negx' + format,
          path + 'posy' + format, path + 'negy' + format,
          path + 'posz' + format, path + 'negz' + format
        ];

        var textureCube = new v3d.CubeTextureLoader().load(urls);
        textureCube.format = v3d.RGBFormat;

        library[textureCube.uuid] = textureCube;

        return textureCube;

      }();

      window.addEventListener('load', init);

      function init() {

        renderer = new v3d.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.uuid = v3d.Math.generateUUID(); // generate to library
        container.appendChild(renderer.domElement);

        scene = new v3d.Scene();

        camera = new v3d.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.x = 50;
        camera.position.z = - 50;
        camera.position.y = 30;
        camera.target = new v3d.Vector3();


        controls = new v3d.OrbitControls(camera, renderer.domElement);
        controls.minDistance = 50;
        controls.maxDistance = 200;

        scene.add(new v3d.AmbientLight(0x464646));

        var light = new v3d.DirectionalLight(0xffddcc, 1);
        light.position.set(1, 0.75, 0.5);
        scene.add(light);

        var light = new v3d.DirectionalLight(0xccccff, 1);
        light.position.set(- 1, 0.75, - 0.5);
        scene.add(light);

        teapot = new v3d.TeapotBufferGeometry(15, 18);

        mesh = new v3d.Mesh(teapot);
        scene.add(mesh);

        library[renderer.uuid] = renderer;
        library[camera.uuid] = camera;
        library[mesh.uuid] = mesh;

        window.addEventListener('resize', onWindowResize, false);

        updateMaterial();

        onWindowResize();
        animate();

      }

      function clearGui() {

        if (gui) gui.destroy();

        gui = new dat.GUI();

        gui.add(param, 'example', {
          'basic / mesh-standard': 'mesh-standard',
          'basic / standard': 'standard',
          'basic / physical': 'physical',
          'basic / phong': 'phong',
          'basic / layers': 'layers',
          'basic / rim': 'rim',
          'basic / color-adjustment': 'color-adjustment',
          'basic / uv-transform': 'uv-transform',
          'basic / bump': 'bump',
          'basic / blur': 'blur',
          'basic / spherical-reflection': 'spherical-reflection',
          'adv / fresnel': 'fresnel',
          'adv / saturation': 'saturation',
          'adv / top-bottom': 'top-bottom',
          'adv / skin': 'skin',
          'adv / skin-phong': 'skin-phong',
          'adv / caustic': 'caustic',
          'adv / displace': 'displace',
          'adv / plush': 'plush',
          'adv / toon': 'toon',
          'adv / camera-depth': 'camera-depth',
          'adv / soft-body': 'soft-body',
          'adv / wave': 'wave',
          'adv / triangle-blur': 'triangle-blur',
          'adv / triplanar-mapping': 'triplanar-mapping',
          'adv / render-to-texture': 'rtt',
          'adv / temporal-blur': 'temporal-blur',
          'adv / conditional': 'conditional',
          'adv / expression': 'expression',
          'adv / sss': 'sss',
          'adv / translucent': 'translucent',
          'node / position': 'node-position',
          'node / normal': 'node-normal',
          'misc / smoke': 'smoke',
          'misc / firefly': 'firefly',
          'misc / reserved-keywords': 'reserved-keywords',
          'misc / varying': 'varying',
          'misc / void-function': 'void-function',
          'misc / readonly': 'readonly',
          'misc / custom-attribute': 'custom-attribute'
        }).onFinishChange(function() {

          updateMaterial();

        });

        gui.open();

      }

      function addGui(name, value, callback, isColor, min, max) {

        var node;

        param[name] = value;

        if (isColor) {

          node = gui.addColor(param, name).onChange(function() {

            callback(param[name]);

          });

        } else if (typeof value == 'object') {

          param[name] = value[Object.keys(value)[0]];

          node = gui.add(param, name, value).onChange(function() {

            callback(param[name]);

          });

        } else {

          node = gui.add(param, name, min, max).onChange(function() {

            callback(param[name]);

          });

        }

        return node;

      }

      function updateMaterial() {

        move = false;

        if (mesh.material) mesh.material.dispose();

        if (rtTexture) {

          delete library[rtTexture.texture.uuid];

          rtTexture.dispose();
          rtTexture = null;

        }

        if (rtMaterial) {

          rtMaterial.dispose();
          rtMaterial = null;

        }

        var name = param.example;
        var mtl;

        clearGui();

        switch (name) {

          case 'phong':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            //mtl.color = // albedo (vec3)
            //mtl.alpha = // opacity (float)
            //mtl.specular = // specular color (vec3)
            //mtl.shininess = // shininess (float)
            //mtl.normal = // normal (vec3)
            //mtl.emissive = // emissive color (vec3)
            //mtl.ambient = // ambient color (vec3)
            //mtl.shadow = // shadowmap (vec3)
            //mtl.light = // custom-light (vec3)
            //mtl.ao = // ambient occlusion (float)
            //mtl.light = // input/output light (vec3)
            //mtl.environment = // reflection/refraction (vec3)
            //mtl.environmentAlpha = // environment alpha (float)
            //mtl.position = // vertex local position (vec3)

            var mask = new v3d.SwitchNode(new v3d.TextureNode(getTexture("decalDiffuse")), 'w');

            mtl.color = new v3d.TextureNode(getTexture("grass"));
            mtl.specular = new v3d.FloatNode(.5);
            mtl.shininess = new v3d.FloatNode(15);
            mtl.environment = new v3d.CubeTextureNode(cubemap);
            mtl.environmentAlpha = mask;
            mtl.normal = new v3d.NormalMapNode(new v3d.TextureNode(getTexture("grassNormal")));
            mtl.normal.scale = new v3d.Math1Node(mask, v3d.Math1Node.INVERT);

            break;

          case 'standard':

            // MATERIAL

            mtl = new v3d.StandardNodeMaterial();

            //mtl.color = // albedo (vec3)
            //mtl.alpha = // opacity (float)
            //mtl.roughness = // roughness (float)
            //mtl.metalness = // metalness (float)
            //mtl.normal = // normal (vec3)
            //mtl.emissive = // emissive color (vec3)
            //mtl.ambient = // ambient color (vec3)
            //mtl.shadow = // shadowmap (vec3)
            //mtl.light = // custom-light (vec3)
            //mtl.ao = // ambient occlusion (float)
            //mtl.environment = // reflection/refraction (vec3)
            //mtl.position = // vertex local position (vec3)

            var mask = new v3d.SwitchNode(new v3d.TextureNode(getTexture("decalDiffuse")), 'w');

            var normalScale = new v3d.FloatNode(.3);

            var roughnessA = new v3d.FloatNode(.5);
            var metalnessA = new v3d.FloatNode(.5);

            var roughnessB = new v3d.FloatNode(0);
            var metalnessB = new v3d.FloatNode(1);

            var roughness = new v3d.Math3Node(
              roughnessA,
              roughnessB,
              mask,
              v3d.Math3Node.MIX
            );

            var metalness = new v3d.Math3Node(
              metalnessA,
              metalnessB,
              mask,
              v3d.Math3Node.MIX
            );

            var normalMask = new v3d.OperatorNode(
              new v3d.Math1Node(mask, v3d.Math1Node.INVERT),
              normalScale,
              v3d.OperatorNode.MUL
            );

            mtl.color = new v3d.ColorNode(0xEEEEEE);
            mtl.roughness = roughness;
            mtl.metalness = metalness;
            mtl.environment = new v3d.CubeTextureNode(cubemap);
            mtl.normal = new v3d.NormalMapNode(new v3d.TextureNode(getTexture("grassNormal")));
            mtl.normal.scale = normalMask;

            // GUI

            addGui('color', mtl.color.value.getHex(), function(val) {

              mtl.color.value.setHex(val);

            }, true);

            addGui('roughnessA', roughnessA.value, function(val) {

              roughnessA.value = val;

            }, false, 0, 1);

            addGui('metalnessA', metalnessA.value, function(val) {

              metalnessA.value = val;

            }, false, 0, 1);

            addGui('roughnessB', roughnessB.value, function(val) {

              roughnessB.value = val;

            }, false, 0, 1);

            addGui('metalnessB', metalnessB.value, function(val) {

              metalnessB.value = val;

            }, false, 0, 1);

            addGui('normalScale', normalScale.value, function(val) {

              normalScale.value = val;

            }, false, 0, 1);

            break;

          case 'mesh-standard':

            // MATERIAL

            var sataturation = new v3d.FloatNode(1),
              useNodeMaterial = true,
              useMap = true,
              useNormals = true;

            function updateMaterial() {

              var oldMaterial = mtl;

              if (oldMaterial) oldMaterial.dispose();

              mtl = useNodeMaterial ? new v3d.MeshStandardNodeMaterial() : new v3d.MeshStandardMaterial();

              // default syntax (backward-compatible)

              mtl.map = useMap ? getTexture("brick") : undefined;

              mtl.normalMap = useNormals ? getTexture("decalNormal") : undefined;
              mtl.normalScale = oldMaterial ? oldMaterial.normalScale : new v3d.Vector2(.5, .5);

              mtl.envMap = cubemap;

              mtl.roughness = oldMaterial ? oldMaterial.roughness : .5;
              mtl.metalness = oldMaterial ? oldMaterial.metalness : .5;

              // extended syntax (only for NodeMaterial)

              if (useNodeMaterial && useMap) {

                mtl.map = new v3d.ColorAdjustmentNode(
                  new v3d.TextureNode(mtl.map),
                  sataturation,
                  v3d.ColorAdjustmentNode.SATURATION
                );

              }

              // apply material

              mtl.side = v3d.DoubleSide;
              mtl.needsUpdate = true;

              mesh.material = mtl;

            }

            updateMaterial();

            // GUI

            addGui('use node material', useNodeMaterial, function(val) {

              useNodeMaterial = val;

              updateMaterial();

            });

            addGui('roughness', mtl.roughness, function(val) {

              mtl.roughness = val;

            }, false, 0, 1);

            addGui('metalness', mtl.roughness, function(val) {

              mtl.metalness = val;

            }, false, 0, 1);

            addGui('normalX', mtl.normalScale.x, function(val) {

              mtl.normalScale.x = val;

            }, false, - 1, 1);

            addGui('normalY', mtl.normalScale.y, function(val) {

              mtl.normalScale.y = val;

            }, false, - 1, 1);

            addGui('sat. (node)', sataturation.value, function(val) {

              sataturation.value = val;

            }, false, 0, 2);

            addGui('colors', useMap, function(val) {

              useMap = val;

              updateMaterial();

            }, false);

            addGui('normals', useNormals, function(val) {

              useNormals = val;

              updateMaterial();

            }, false);

            break;

          case 'physical':

            // MATERIAL

            mtl = new v3d.StandardNodeMaterial();

            //mtl.color = // albedo (vec3)
            //mtl.alpha = // opacity (float)
            //mtl.roughness = // roughness (float)
            //mtl.metalness = // metalness (float)
            //mtl.reflectivity = // reflectivity (float)
            //mtl.clearCoat = // clearCoat (float)
            //mtl.clearCoatRoughness = // clearCoatRoughness (float)
            //mtl.normal = // normal (vec3)
            //mtl.emissive = // emissive color (vec3)
            //mtl.ambient = // ambient color (vec3)
            //mtl.shadow = // shadowmap (vec3)
            //mtl.light = // custom-light (vec3)
            //mtl.ao = // ambient occlusion (float)
            //mtl.environment = // reflection/refraction (vec3)
            //mtl.position = // vertex local position (vec3)

            var mask = new v3d.SwitchNode(new v3d.TextureNode(getTexture("decalDiffuse")), 'w');

            var normalScale = new v3d.FloatNode(.3);

            var roughnessA = new v3d.FloatNode(.5);
            var metalnessA = new v3d.FloatNode(.5);

            var roughnessB = new v3d.FloatNode(0);
            var metalnessB = new v3d.FloatNode(1);

            var reflectivity = new v3d.FloatNode(0);
            var clearCoat = new v3d.FloatNode(1);
            var clearCoatRoughness = new v3d.FloatNode(1);

            var roughness = new v3d.Math3Node(
              roughnessA,
              roughnessB,
              mask,
              v3d.Math3Node.MIX
            );

            var metalness = new v3d.Math3Node(
              metalnessA,
              metalnessB,
              mask,
              v3d.Math3Node.MIX
            );

            var normalMask = new v3d.OperatorNode(
              new v3d.Math1Node(mask, v3d.Math1Node.INVERT),
              normalScale,
              v3d.OperatorNode.MUL
            );

            mtl.color = new v3d.ColorNode(0xEEEEEE);
            mtl.roughness = roughness;
            mtl.metalness = metalness;
            mtl.reflectivity = reflectivity;
            mtl.clearCoat = clearCoat;
            mtl.clearCoatRoughness = clearCoatRoughness;
            mtl.environment = new v3d.CubeTextureNode(cubemap);
            mtl.normal = new v3d.NormalMapNode(new v3d.TextureNode(getTexture("grassNormal")));
            mtl.normal.scale = normalMask;

            // GUI

            addGui('color', mtl.color.value.getHex(), function(val) {

              mtl.color.value.setHex(val);

            }, true);

            addGui('reflectivity', reflectivity.value, function(val) {

              reflectivity.value = val;

            }, false, 0, 1);

            addGui('clearCoat', clearCoat.value, function(val) {

              clearCoat.value = val;

            }, false, 0, 1);

            addGui('clearCoatRoughness', clearCoatRoughness.value, function(val) {

              clearCoatRoughness.value = val;

            }, false, 0, 1);

            addGui('roughnessA', roughnessA.value, function(val) {

              roughnessA.value = val;

            }, false, 0, 1);

            addGui('metalnessA', metalnessA.value, function(val) {

              metalnessA.value = val;

            }, false, 0, 1);

            addGui('roughnessB', roughnessB.value, function(val) {

              roughnessB.value = val;

            }, false, 0, 1);

            addGui('metalnessB', metalnessB.value, function(val) {

              metalnessB.value = val;

            }, false, 0, 1);

            addGui('normalScale', normalScale.value, function(val) {

              normalScale.value = val;

            }, false, 0, 1);

            break;

          case 'wave':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var time = new v3d.TimerNode();
            var speed = new v3d.FloatNode(5);
            var scale = new v3d.FloatNode(1);
            var worldScale = new v3d.FloatNode(.4);
            var colorA = new v3d.ColorNode(0xFFFFFF);
            var colorB = new v3d.ColorNode(0x0054df);

            // used for serialization only
            time.name = "time";
            speed.name = "speed";

            var timeScale = new v3d.OperatorNode(
              time,
              speed,
              v3d.OperatorNode.MUL
            );

            var worldScl = new v3d.OperatorNode(
              new v3d.PositionNode(),
              worldScale,
              v3d.OperatorNode.MUL
            );

            var posContinuous = new v3d.OperatorNode(
              worldScl,
              timeScale,
              v3d.OperatorNode.ADD
            );

            var wave = new v3d.Math1Node(posContinuous, v3d.Math1Node.SIN);
            wave = new v3d.SwitchNode(wave, 'x');

            var waveScale = new v3d.OperatorNode(
              wave,
              scale,
              v3d.OperatorNode.MUL
            );

            var displaceY = new v3d.JoinNode(
              new v3d.FloatNode(),
              waveScale,
              new v3d.FloatNode()
            );

            var displace = new v3d.OperatorNode(
              new v3d.NormalNode(),
              displaceY,
              v3d.OperatorNode.MUL
            );

            var blend = new v3d.OperatorNode(
              new v3d.PositionNode(),
              displaceY,
              v3d.OperatorNode.ADD
            );

            var color = new v3d.Math3Node(
              colorB,
              colorA,
              wave,
              v3d.Math3Node.MIX
            );

            mtl.color = color;
            mtl.position = blend;

            // GUI

            addGui('speed', speed.value, function(val) {

              speed.value = val;

            }, false, 0, 10);

            addGui('scale', scale.value, function(val) {

              scale.value = val;

            }, false, 0, 3);

            addGui('worldScale', worldScale.value, function(val) {

              worldScale.value = val;

            }, false, 0, 1);

            addGui('colorA', colorA.value.getHex(), function(val) {

              colorA.value.setHex(val);

            }, true);

            addGui('colorB', colorB.value.getHex(), function(val) {

              colorB.value.setHex(val);

            }, true);

            addGui('useNormals', false, function(val) {

              blend.b = val ? displace : displaceY;

              mtl.needsUpdate = true;

            });

            break;

          case 'rim':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var intensity = 1.3;
            var power = new v3d.FloatNode(3);
            var color = new v3d.ColorNode(0xFFFFFF);

            var viewZ = new v3d.Math2Node(
              new v3d.NormalNode(),
              new v3d.Vector3Node(0, 0, - intensity),
              v3d.Math2Node.DOT
            );

            var rim = new v3d.OperatorNode(
              viewZ,
              new v3d.FloatNode(intensity),
              v3d.OperatorNode.ADD
            );

            var rimPower = new v3d.Math2Node(
              rim,
              power,
              v3d.Math2Node.POW
            );

            var rimColor = new v3d.OperatorNode(
              rimPower,
              color,
              v3d.OperatorNode.MUL
            );

            mtl.color = new v3d.ColorNode(0x111111);
            mtl.emissive = rimColor;

            // GUI

            addGui('color', color.value.getHex(), function(val) {

              color.value.setHex(val);

            }, true);

            addGui('intensity', intensity, function(val) {

              intensity = val;

              viewZ.b.z = - intensity;
              rim.b.value = intensity;


            }, false, 0, 3);

            addGui('power', power.value, function(val) {

              power.value = val;

            }, false, 0, 6);

            addGui('xray', false, function(val) {

              if (val) {

                mtl.emissive = color;
                mtl.alpha = rimPower;
                mtl.blending = v3d.AdditiveBlending;
                mtl.depthWrite = false;

              }        else {

                mtl.emissive = rimColor;
                mtl.alpha = null;
                mtl.blending = v3d.NormalBlending;
                mtl.depthWrite = true;

              }

              mtl.needsUpdate = true;

            });

            break;

          case 'color-adjustment':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var texture = new v3d.TextureNode(getTexture("brick"));

            var hue = new v3d.FloatNode();
            var sataturation = new v3d.FloatNode(1);
            var vibrance = new v3d.FloatNode();
            var brightness = new v3d.FloatNode(0);
            var contrast = new v3d.FloatNode(1);

            var hueNode = new v3d.ColorAdjustmentNode(texture, hue, v3d.ColorAdjustmentNode.HUE);
            var satNode = new v3d.ColorAdjustmentNode(hueNode, sataturation, v3d.ColorAdjustmentNode.SATURATION);
            var vibranceNode = new v3d.ColorAdjustmentNode(satNode, vibrance, v3d.ColorAdjustmentNode.VIBRANCE);
            var brightnessNode = new v3d.ColorAdjustmentNode(vibranceNode, brightness, v3d.ColorAdjustmentNode.BRIGHTNESS);
            var contrastNode = new v3d.ColorAdjustmentNode(brightnessNode, contrast, v3d.ColorAdjustmentNode.CONTRAST);

            mtl.color = contrastNode;

            // GUI

            addGui('hue', hue.value, function(val) {

              hue.value = val;

            }, false, 0, Math.PI * 2);

            addGui('saturation', sataturation.value, function(val) {

              sataturation.value = val;

            }, false, 0, 2);

            addGui('vibrance', vibrance.value, function(val) {

              vibrance.value = val;

            }, false, - 1, 1);

            addGui('brightness', brightness.value, function(val) {

              brightness.value = val;

            }, false, 0, .5);

            addGui('contrast', contrast.value, function(val) {

              contrast.value = val;

            }, false, 0, 2);

            break;

          case 'uv-transform':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var translate = new v3d.Vector2();
            var rotate = 0;
            var scale = new v3d.Vector2(1, 1);

            var texture = new v3d.TextureNode(getTexture("brick"));
            texture.uv = new v3d.UVTransformNode();
            //texture.uv.uv = new v3d.UVNode(1); // uv2 for example

            mtl.color = texture;

            // GUI

            function updateUVTransform() {

              texture.uv.setUvTransform(translate.x, translate.y, scale.x, scale.y, v3d.Math.degToRad(rotate));

            }

            addGui('translateX', translate.x, function(val) {

              translate.x = val;

              updateUVTransform();

            }, false, 0, 10);

            addGui('translateY', translate.y, function(val) {

              translate.y = val;

              updateUVTransform();

            }, false, 0, 10);

            addGui('scaleX', scale.x, function(val) {

              scale.x = val;

              updateUVTransform();

            }, false, .1, 5);

            addGui('scaleY', scale.y, function(val) {

              scale.y = val;

              updateUVTransform();

            }, false, .1, 5);

            addGui('rotate', rotate, function(val) {

              rotate = val;

              updateUVTransform();

            }, false, 0, 360);

            break;

          case 'bump':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var diffuse = new v3d.TextureNode(getTexture("brick"));

            var bumpMap = new v3d.BumpMapNode(new v3d.TextureNode(getTexture("brick")));
            bumpMap.scale = new v3d.FloatNode(.5);

            mtl.color = diffuse;
            mtl.normal = bumpMap;

            // convert BumpMap to NormalMap
            //bumpMap.toNormalMap = true;
            //mtl.normal = new v3d.NormalMapNode(bumpMap);

            // GUI

            addGui('scale', bumpMap.scale.value, function(val) {

              bumpMap.scale.value = val;

            }, false, - 2, 2);

            addGui('color', true, function(val) {

              mtl.color = val ? diffuse : new v3d.ColorNode(0xEEEEEE);

              mtl.needsUpdate = true;

            });

            break;

          case 'blur':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var diffuse = new v3d.TextureNode(getTexture("brick"));

            var blur = new v3d.BlurNode(new v3d.TextureNode(getTexture("brick")));

            mtl.color = blur;

            // GUI

            addGui('radiusX', blur.radius.x, function(val) {

              blur.radius.x = val;

            }, false, 0, 15);

            addGui('radiusY', blur.radius.y, function(val) {

              blur.radius.y = val;

            }, false, 0, 15);

            break;

          case 'spherical-reflection':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            mtl.environment = new v3d.TextureNode(getTexture("spherical"), new v3d.ReflectNode(v3d.ReflectNode.SPHERE));

            break;

          case 'fresnel':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var reflectance = new v3d.FloatNode(1.3);
            var power = new v3d.FloatNode(1);
            var color = new v3d.CubeTextureNode(cubemap);

            var viewZ = new v3d.Math2Node(
              new v3d.NormalNode(),
              new v3d.Vector3Node(0, 0, - 1),
              v3d.Math2Node.DOT
            );

            var theta = new v3d.OperatorNode(
              viewZ,
              new v3d.FloatNode(1),
              v3d.OperatorNode.ADD
            );

            var thetaPower = new v3d.Math2Node(
              theta,
              power,
              v3d.Math2Node.POW
            );

            var fresnel = new v3d.OperatorNode(
              reflectance,
              thetaPower,
              v3d.OperatorNode.MUL
            );

            mtl.color = new v3d.ColorNode(0x3399FF);
            mtl.environment = color;
            mtl.environmentAlpha = new v3d.Math1Node(fresnel, v3d.Math1Node.SAT);

            // GUI

            addGui('reflectance', reflectance.value, function(val) {

              reflectance.value = val;

            }, false, 0, 3);

            addGui('power', power.value, function(val) {

              power.value = val;

            }, false, 0, 5);

            break;

          case 'layers':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var tex1 = new v3d.TextureNode(getTexture("grass"));
            var tex2 = new v3d.TextureNode(getTexture("brick"));

            var offset = new v3d.FloatNode(0);
            var scale = new v3d.FloatNode(1);
            var uv = new v3d.UVNode();

            var uvOffset = new v3d.OperatorNode(
              offset,
              uv,
              v3d.OperatorNode.ADD
            );

            var uvScale = new v3d.OperatorNode(
              uvOffset,
              scale,
              v3d.OperatorNode.MUL
            );

            var mask = new v3d.TextureNode(getTexture("decalDiffuse"), uvScale);
            var maskAlphaChannel = new v3d.SwitchNode(mask, 'w');

            var blend = new v3d.Math3Node(
              tex1,
              tex2,
              maskAlphaChannel,
              v3d.Math3Node.MIX
            );

            mtl.color = blend;

            // GUI

            addGui('offset', offset.value, function(val) {

              offset.value = val;

            }, false, 0, 1);

            addGui('scale', scale.value, function(val) {

              scale.value = val;

            }, false, 0, 10);

            break;

          case 'saturation':

            // MATERIAL

            mtl = new v3d.StandardNodeMaterial();

            var tex = new v3d.TextureNode(getTexture("brick"));
            var sat = new v3d.FloatNode(0);

            var satrgb = new v3d.FunctionNode([
              "vec3 satrgb(vec3 rgb, float adjustment) {",
              // include luminance function from LuminanceNode
              "  vec3 intensity = vec3(luminance(rgb));",
              "  return mix(intensity, rgb, adjustment);",
              "}"
            ].join("\n"), [v3d.LuminanceNode.Nodes.luminance]);

            var saturation = new v3d.FunctionCallNode(satrgb);
            saturation.inputs.rgb = tex;
            saturation.inputs.adjustment = sat;

            // or try

            //saturation.inputs[0] = tex;
            //saturation.inputs[1] = sat;

            mtl.color = saturation;

            // GUI

            addGui('saturation', sat.value, function(val) {

              sat.value = val;

            }, false, 0, 2);

            break;

          case 'top-bottom':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var top = new v3d.TextureNode(getTexture("grass"));
            var bottom = new v3d.TextureNode(getTexture("brick"));

            var normal = new v3d.NormalNode(v3d.NormalNode.WORLD);
            var normalY = new v3d.SwitchNode(normal, 'y');

            var hard = new v3d.FloatNode(9);
            var offset = new v3d.FloatNode(- 2.5);

            var hardClamp = new v3d.OperatorNode(
              normalY,
              hard,
              v3d.OperatorNode.MUL
            );

            var offsetClamp = new v3d.OperatorNode(
              hardClamp,
              offset,
              v3d.OperatorNode.ADD
            );

            var clamp0at1 = new v3d.Math1Node(offsetClamp, v3d.Math1Node.SAT);

            var blend = new v3d.Math3Node(top, bottom, clamp0at1, v3d.Math3Node.MIX);

            mtl.color = blend;

            // GUI

            addGui('hard', hard.value, function(val) {

              hard.value = val;

            }, false, 0, 20);

            addGui('offset', offset.value, function(val) {

              offset.value = val;

            }, false, - 10, 10);

            break;

          case 'displace':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var time = new v3d.TimerNode();
            var scale = new v3d.FloatNode(2);
            var speed = new v3d.FloatNode(.2);
            var colorA = new v3d.ColorNode(0xFFFFFF);
            var colorB = new v3d.ColorNode(0x0054df);

            // used for serialization only
            time.name = "time";
            speed.name = "speed";

            var uv = new v3d.UVNode();

            var timeScl = new v3d.OperatorNode(
              time,
              speed,
              v3d.OperatorNode.MUL
            );

            var displaceOffset = new v3d.OperatorNode(
              timeScl,
              uv,
              v3d.OperatorNode.ADD
            );

            var tex = new v3d.TextureNode(getTexture("cloud"), displaceOffset);
            var texArea = new v3d.SwitchNode(tex, 'w');

            var displace = new v3d.OperatorNode(
              new v3d.NormalNode(),
              texArea,
              v3d.OperatorNode.MUL
            );

            var displaceScale = new v3d.OperatorNode(
              displace,
              scale,
              v3d.OperatorNode.MUL
            );

            var blend = new v3d.OperatorNode(
              new v3d.PositionNode(),
              displaceScale,
              v3d.OperatorNode.ADD
            );

            var color = new v3d.Math3Node(
              colorB,
              colorA,
              texArea,
              v3d.Math3Node.MIX
            );

            mtl.color = mtl.specular = new v3d.ColorNode(0);
            mtl.emissive = color;
            mtl.position = blend;

            // GUI

            addGui('speed', speed.value, function(val) {

              speed.value = val;

            }, false, 0, 1);

            addGui('scale', scale.value, function(val) {

              scale.value = val;

            }, false, 0, 10);

            addGui('colorA', colorA.value.getHex(), function(val) {

              colorA.value.setHex(val);

            }, true);

            addGui('colorB', colorB.value.getHex(), function(val) {

              colorB.value.setHex(val);

            }, true);

            break;

          case 'smoke':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var time = new v3d.TimerNode();
            var uv = new v3d.UVNode();

            var timeSpeedA = new v3d.OperatorNode(
              time,
              new v3d.Vector2Node(0.3, 0.1),
              v3d.OperatorNode.MUL
            );

            var timeSpeedB = new v3d.OperatorNode(
              time,
              new v3d.Vector2Node(0.15, 0.4),
              v3d.OperatorNode.MUL
            );

            var uvOffsetA = new v3d.OperatorNode(
              timeSpeedA,
              uv,
              v3d.OperatorNode.ADD
            );

            var uvOffsetB = new v3d.OperatorNode(
              timeSpeedB,
              uv,
              v3d.OperatorNode.ADD
            );

            var cloudA = new v3d.TextureNode(getTexture("cloud"), uvOffsetA);
            var cloudB = new v3d.TextureNode(getTexture("cloud"), uvOffsetB);

            var clouds = new v3d.OperatorNode(
              cloudA,
              cloudB,
              v3d.OperatorNode.ADD
            );

            mtl.environment = new v3d.ColorNode(0xFFFFFF);
            mtl.alpha = clouds;

            // GUI

            addGui('color', mtl.environment.value.getHex(), function(val) {

              mtl.environment.value.setHex(val);

            }, true);

            break;

          case 'camera-depth':

            // MATERIAL

            var colorA = new v3d.ColorNode(0xFFFFFF);
            var colorB = new v3d.ColorNode(0x0054df);

            var depth = new v3d.CameraNode(v3d.CameraNode.DEPTH);
            depth.near.value = 1;
            depth.far.value = 200;

            var colors = new v3d.Math3Node(
              colorB,
              colorA,
              depth,
              v3d.Math3Node.MIX
            );

            mtl = new v3d.PhongNodeMaterial();
            mtl.color = colors;

            // GUI

            addGui('near', depth.near.value, function(val) {

              depth.near.value = val;

            }, false, 1, 1200);

            addGui('far', depth.far.value, function(val) {

              depth.far.value = val;

            }, false, 1, 1200);

            addGui('nearColor', colorA.value.getHex(), function(val) {

              colorA.value.setHex(val);

            }, true);

            addGui('farColor', colorB.value.getHex(), function(val) {

              colorB.value.setHex(val);

            }, true);

            break;

          case 'caustic':

            // MATERIAL

            mtl = new v3d.StandardNodeMaterial();

            var hash2 = new v3d.FunctionNode([
              "vec2 hash2(vec2 p) {",
              "  return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);",
              "}"
            ].join("\n"));

            var voronoi = new v3d.FunctionNode([
              // Based off of iq's described here: http://www.iquilezles.org/www/articles/voronoili
              "float voronoi(vec2 p, in float time) {",
              "  vec2 n = floor(p);",
              "  vec2 f = fract(p);",
              "  float md = 5.0;",
              "  vec2 m = vec2(0.0);",
              "  for (int i = -1; i <= 1; i++) {",
              "    for (int j = -1; j <= 1; j++) {",
              "      vec2 g = vec2(i, j);",
              "      vec2 o = hash2(n + g);",
              "      o = 0.5 + 0.5 * sin(time + 5.038 * o);",
              "      vec2 r = g + o - f;",
              "      float d = dot(r, r);",
              "      if (d < md) {",
              "        md = d;",
              "        m = n+g+o;",
              "      }",
              "    }",
              "  }",
              "  return md;",
              "}"
            ].join("\n"), [hash2]); // define hash2 as dependencies

            var voronoiLayers = new v3d.FunctionNode([
              // based on https://www.shadertoy.com/view/4tXSDf
              "float voronoiLayers(vec2 p, in float time) {",
              "  float v = 0.0;",
              "  float a = 0.4;",
              "  for (int i = 0; i < 3; i++) {",
              "    v += voronoi(p, time) * a;",
              "    p *= 2.0;",
              "    a *= 0.5;",
              "  }",
              "  return v;",
              "}"
            ].join("\n"), [voronoi]); // define voronoi as dependencies

            var time = new v3d.TimerNode();
            var timeScale = new v3d.FloatNode(2);

            // used for serialization only
            time.name = "time";
            timeScale.name = "speed";

            var alpha = new v3d.FloatNode(1);
            var scale = new v3d.FloatNode(.1);
            var intensity = new v3d.FloatNode(1.5);

            var color = new v3d.ColorNode(0xFFFFFF);
            var colorA = new v3d.ColorNode(0xFFFFFF);
            var colorB = new v3d.ColorNode(0x0054df);

            var worldPos = new v3d.PositionNode(v3d.PositionNode.WORLD);
            var worldPosTop = new v3d.SwitchNode(worldPos, 'xz');

            var worldNormal = new v3d.NormalNode(v3d.NormalNode.WORLD);

            var mask = new v3d.SwitchNode(worldNormal, 'y');

            // clamp0at1
            mask = new v3d.Math1Node(mask, v3d.Math1Node.SAT);

            var timeOffset = new v3d.OperatorNode(
              time,
              timeScale,
              v3d.OperatorNode.MUL
            );

            var uvPos = new v3d.OperatorNode(
              worldPosTop,
              scale,
              v3d.OperatorNode.MUL
            );

            var voronoi = new v3d.FunctionCallNode(voronoiLayers);
            voronoi.inputs.p = uvPos;
            voronoi.inputs.time = timeOffset;

            var maskCaustic = new v3d.OperatorNode(
              alpha,
              mask,
              v3d.OperatorNode.MUL
            );

            var voronoiIntensity = new v3d.OperatorNode(
              voronoi,
              intensity,
              v3d.OperatorNode.MUL
            );

            var voronoiColors = new v3d.Math3Node(
              colorB,
              colorA,
              new v3d.Math1Node(voronoiIntensity, v3d.Math1Node.SAT), // mix needs clamp
              v3d.Math3Node.MIX
            );

            var caustic = new v3d.Math3Node(
              color,
              voronoiColors,
              maskCaustic,
              v3d.Math3Node.MIX
            );

            var causticLights = new v3d.OperatorNode(
              voronoiIntensity,
              maskCaustic,
              v3d.OperatorNode.MUL
            );

            mtl.color = caustic;
            mtl.ambient = causticLights;

            // GUI

            addGui('timeScale', timeScale.value, function(val) {

              timeScale.value = val;

            }, false, 0, 5);

            addGui('intensity', intensity.value, function(val) {

              intensity.value = val;

            }, false, 0, 3);

            addGui('scale', scale.value, function(val) {

              scale.value = val;

            }, false, 0, 1);

            addGui('alpha', alpha.value, function(val) {

              alpha.value = val;

            }, false, 0, 1);

            addGui('color', color.value.getHex(), function(val) {

              color.value.setHex(val);

            }, true);

            addGui('colorA', colorA.value.getHex(), function(val) {

              colorA.value.setHex(val);

            }, true);

            addGui('colorB', colorB.value.getHex(), function(val) {

              colorB.value.setHex(val);

            }, true);

            break;

          case 'soft-body':

            // MATERIAL

            move = true;

            mtl = new v3d.StandardNodeMaterial();

            var scale = new v3d.FloatNode(2);
            var colorA = new v3d.ColorNode(0xFF6633);
            var colorB = new v3d.ColorNode(0x3366FF);

            var pos = new v3d.PositionNode();
            var posNorm = new v3d.Math1Node(pos, v3d.Math1Node.NORMALIZE);

            var mask = new v3d.SwitchNode(posNorm, 'y');

            var velocity = new v3d.VelocityNode(mesh, {
              type: 'elastic',
              spring: .95,
              damping: .95
            });

            var velocityArea = new v3d.OperatorNode(
              mask,
              scale,
              v3d.OperatorNode.MUL
            );

            var softVelocity = new v3d.OperatorNode(
              velocity,
              velocityArea,
              v3d.OperatorNode.MUL
            );

            var softPosition = new v3d.OperatorNode(
              new v3d.PositionNode(),
              softVelocity,
              v3d.OperatorNode.ADD
            );

            var colors = new v3d.Math3Node(
              colorB,
              colorA,
              mask,
              v3d.Math3Node.MIX
            );

            mtl.color = colors;
            mtl.position = softPosition;

            // GUI

            addGui('spring', velocity.params.spring, function(val) {

              velocity.params.spring = val;

            }, false, 0, .95);

            addGui('damping', velocity.params.damping, function(val) {

              velocity.params.damping = val;

            }, false, 0, .95);

            addGui('scale', scale.value, function(val) {

              scale.value = val;

            }, false, 0, 3);

            addGui('softBody', colorA.value.getHex(), function(val) {

              colorA.value.setHex(val);

            }, true);

            addGui('rigidBody', colorB.value.getHex(), function(val) {

              colorB.value.setHex(val);

            }, true);

            break;

          case 'plush':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var color = new v3d.ColorNode(0x8D8677);
            var mildness = new v3d.FloatNode(1.6);
            var fur = new v3d.FloatNode(.5);

            var posDirection = new v3d.Math1Node(new v3d.PositionNode(v3d.PositionNode.VIEW), v3d.Math1Node.NORMALIZE);
            var norDirection = new v3d.Math1Node(new v3d.NormalNode(), v3d.Math1Node.NORMALIZE);

            var viewZ = new v3d.Math2Node(
              posDirection,
              norDirection,
              v3d.Math2Node.DOT
            );

            // without luma correction for now
            var mildnessColor = new v3d.OperatorNode(
              color,
              mildness,
              v3d.OperatorNode.MUL
            );

            var furScale = new v3d.OperatorNode(
              viewZ,
              fur,
              v3d.OperatorNode.MUL
            );

            mtl.color = color;
            mtl.normal = new v3d.NormalMapNode(new v3d.TextureNode(getTexture("grassNormal")));
            mtl.normal.scale = furScale;
            mtl.environment = mildnessColor;
            mtl.environmentAlpha = new v3d.Math1Node(viewZ, v3d.Math1Node.INVERT);
            mtl.shininess = new v3d.FloatNode(0);

            // GUI

            addGui('color', color.value.getHex(), function(val) {

              color.value.setHex(val);

            }, true);

            addGui('mildness', mildness.value, function(val) {

              mildness.value = val;

            }, false, 1, 2);

            addGui('fur', fur.value, function(val) {

              fur.value = val;

            }, false, 0, 2);

            break;

          case 'skin':
          case 'skin-phong':

            // MATERIAL

            mtl = name == 'skin' ? new v3d.StandardNodeMaterial() : new v3d.PhongNodeMaterial();

            var skinColor = new v3d.ColorNode(0xFFC495);
            var bloodColor = new v3d.ColorNode(0x6b0602);
            var wrapLight = new v3d.FloatNode(1.5);
            var wrapShadow = new v3d.FloatNode(0);

            var directLight = new v3d.LightNode();

            var lightLuminance = new v3d.LuminanceNode(directLight);

            var lightWrap = new v3d.Math3Node(
              wrapShadow,
              wrapLight,
              lightLuminance,
              v3d.Math3Node.SMOOTHSTEP
            );

            var lightTransition = new v3d.OperatorNode(
              lightWrap,
              new v3d.ConstNode(v3d.ConstNode.PI2),
              v3d.OperatorNode.MUL
            );

            var wrappedLight = new v3d.Math1Node(lightTransition, v3d.Math1Node.SIN);

            var wrappedLightColor = new v3d.OperatorNode(
              wrappedLight,
              bloodColor,
              v3d.OperatorNode.MUL
            );

            var bloodArea = new v3d.Math1Node(wrappedLightColor, v3d.Math1Node.SAT);

            var totalLight = new v3d.OperatorNode(
              directLight,
              bloodArea,
              v3d.OperatorNode.ADD
            );

            mtl.color = skinColor;
            mtl.light = totalLight;

            if (name == 'skin') {

              // StandardNodeMaterial

              mtl.metalness = new v3d.FloatNode(0);
              mtl.roughness = new v3d.FloatNode(1);
              mtl.reflectivity = new v3d.FloatNode(0);
              mtl.clearCoat = new v3d.FloatNode(.2);
              mtl.clearCoatRoughness = new v3d.FloatNode(.3);
              mtl.environment = new v3d.CubeTextureNode(cubemap);

            } else {

              // PhongNodeMaterial

              mtl.specular = new v3d.ColorNode(0x2f2e2d);
              mtl.shininess = new v3d.FloatNode(15);

            }

            // GUI

            addGui('skinColor', skinColor.value.getHex(), function(val) {

              skinColor.value.setHex(val);

            }, true);

            addGui('bloodColor', bloodColor.value.getHex(), function(val) {

              bloodColor.value.setHex(val);

            }, true);

            addGui('wrapLight', wrapLight.value, function(val) {

              wrapLight.value = val;

            }, false, 0, 3);

            addGui('wrapShadow', wrapShadow.value, function(val) {

              wrapShadow.value = val;

            }, false, - 1, 0);

            break;

          case 'toon':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var count = new v3d.FloatNode(3.43);
            var sceneDirectLight = new v3d.LightNode();
            var color = new v3d.ColorNode(0xAABBFF);

            var lineColor = new v3d.ColorNode(0xFF0000);
            var lineSize = new v3d.FloatNode(0.23);
            var lineInner = new v3d.FloatNode(0);

            // CEL

            var lightLuminance = new v3d.LuminanceNode(sceneDirectLight);

            var preCelLight = new v3d.OperatorNode(
              lightLuminance,
              count,
              v3d.OperatorNode.MUL
            );

            var celLight = new v3d.Math1Node(
              preCelLight,
              v3d.Math1Node.CEIL
            );

            var posCelLight = new v3d.OperatorNode(
              celLight,
              count,
              v3d.OperatorNode.DIV
            );

            // LINE

            var posDirection = new v3d.Math1Node(new v3d.PositionNode(v3d.PositionNode.VIEW), v3d.Math1Node.NORMALIZE);
            var norDirection = new v3d.Math1Node(new v3d.NormalNode(), v3d.Math1Node.NORMALIZE);

            var viewZ = new v3d.Math2Node(
              posDirection,
              norDirection,
              v3d.Math2Node.DOT
            );

            var lineOutside = new v3d.Math1Node(
              viewZ,
              v3d.Math1Node.ABS
            );

            var line = new v3d.OperatorNode(
              lineOutside,
              new v3d.FloatNode(1),
              v3d.OperatorNode.DIV
            );

            var lineScaled = new v3d.Math3Node(
              line,
              lineSize,
              lineInner,
              v3d.Math3Node.SMOOTHSTEP
            );

            var innerContour = new v3d.Math1Node(new v3d.Math1Node(lineScaled, v3d.Math1Node.SAT), v3d.Math1Node.INVERT);

            // APPLY

            mtl.color = color;
            mtl.light = posCelLight;
            mtl.shininess = new v3d.FloatNode(0);

            mtl.environment = lineColor;
            mtl.environmentAlpha = innerContour;

            // GUI

            addGui('color', color.value.getHex(), function(val) {

              color.value.setHex(val);

            }, true);

            addGui('lineColor', lineColor.value.getHex(), function(val) {

              lineColor.value.setHex(val);

            }, true);

            addGui('count', count.value, function(val) {

              count.value = val;

            }, false, 1, 8);

            addGui('lineSize', lineSize.value, function(val) {

              lineSize.value = val;

            }, false, 0, 1);

            addGui('lineInner', lineInner.value, function(val) {

              lineInner.value = val;

            }, false, 0, 1);

            addGui('ignoreIndirectLight', false, function(val) {

              mtl.ao = val ? new v3d.FloatNode() : undefined;

              mtl.needsUpdate = true;

            });

            break;

          case 'custom-attribute':

            // GEOMETRY

            // add "position" buffer to "custom" attribute
            teapot.attributes['custom'] = teapot.attributes['position'];

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            mtl.color = new v3d.AttributeNode("custom", 3);

            // or

            //mtl.color = new v3d.AttributeNode("custom", "vec3");

            break;

          case 'expression':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var speed = new v3d.FloatNode(.5);

            mtl.color = new v3d.ExpressionNode("myCustomUv + (sin(time*speed)*.5) + (position * .05)", "vec3");
            mtl.color.keywords["speed"] = speed;

            mtl.position = new v3d.ExpressionNode("mod(time*speed,1.0) < 0.5 ? position + (worldNormal*(1.0+sin(time*speed*1.0))*3.0) : position + sin(position.x * sin(time*speed*2.0))", "vec3");
            mtl.position.keywords["speed"] = speed;

            // add global keyword (variable or const)
            v3d.NodeLib.addKeyword('myCustomUv', function() {

              return new v3d.ReflectNode();

            });

            // GUI

            addGui('speed', speed.value, function(val) {

              speed.value = val;

            }, false, 0, 1);

            break;

          case 'reserved-keywords':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var keywordsexample = new v3d.FunctionNode([
              // use "uv" reserved keyword
              "vec4 keywordsexample(sampler2D texture) {",
              "  return texture2D(texture, myUV) + vec4(position * myAlpha, 0.0);",
              "}"
            ].join("\n"));

            // add local keyword (const only)
            keywordsexample.keywords["myAlpha"] = new v3d.ConstNode("float myAlpha .05");

            // add global keyword (const only)
            v3d.NodeLib.addKeyword('myUV', function() {

              return new v3d.UVNode();

            });

            // add global const or function
            //v3d.NodeLib.add(new v3d.ConstNode("float MY_CONST .05"))

            // reserved keywords
            console.log(v3d.NodeLib.keywords);

            // keywords conflit? use this to disable:
            //blurtexture.useKeywords = false; // (true is default)

            mtl.color = new v3d.FunctionCallNode(keywordsexample, [new v3d.TextureNode(getTexture("brick"))]);

            break;

          case 'node-position':

            // MATERIAL

            var node = new v3d.PositionNode();

            mtl = new v3d.PhongNodeMaterial();
            mtl.color = node;

            // GUI

            addGui('scope', {
              local: v3d.PositionNode.LOCAL,
              world: v3d.PositionNode.WORLD,
              view: v3d.PositionNode.VIEW
            }, function(val) {

              node.scope = val;

              mtl.needsUpdate = true;

            });

            break;

          case 'node-normal':

            // MATERIAL

            var node = new v3d.NormalNode();

            mtl = new v3d.PhongNodeMaterial();
            mtl.color = node;

            // GUI

            addGui('scope', {
              local: v3d.NormalNode.LOCAL,
              world: v3d.NormalNode.WORLD,
              view: v3d.NormalNode.VIEW
            }, function(val) {

              node.scope = val;

              mtl.needsUpdate = true;

            });

            break;

          case 'varying':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var varying = new v3d.VarNode("vec3");
            varying.value = new v3d.NormalNode(v3d.NormalNode.VIEW);

            // using BypassNode the NormalNode not apply the value in .position slot
            // but set the NormalNode value in VarNode
            // it can be useful to send values between vertex to fragment shader
            // without affect vertex shader
            mtl.position = new v3d.BypassNode(varying);
            mtl.color = varying;

            // you can also set a independent value in .position slot using BypassNode
            // such this expression using ExpressionNode
            mtl.position.value = new v3d.ExpressionNode("position * (.1 + abs(sin(time)))", "vec3");

            break;

          case 'void-function':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var varying = new v3d.VarNode("vec3");

            // VERTEX

            var setMyVar = new v3d.FunctionNode([
              "void setMyVar(vec3 pos) {",
              // set "myVar" in vertex shader in this example,
              // can be used in fragment shader too or in rest of the current shader
              "  myVar = pos;",

              "}"
            ].join("\n"));

            // add keyword
            setMyVar.keywords["myVar"] = varying;

            var position = new v3d.ExpressionNode("setMyVar(position * .1)", "vec3");
            position.includes = [setMyVar];
            position.keywords["tex"] = new v3d.TextureNode(getTexture("brick"));

            // use BypassNode to "void" functions
            mtl.position = new v3d.BypassNode(position);

            // FRAGMENT

            var clipFromPos = new v3d.FunctionNode([
              "void clipFromPos(vec3 pos) {",

              "  if (pos.y < .0) discard;",

              "}"
            ].join("\n"));

            var clipFromPosCall = new v3d.FunctionCallNode(clipFromPos, {
              pos: varying
            });

            mtl.color = new v3d.BypassNode(clipFromPosCall, varying);

            break;

          case 'conditional':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var a = new v3d.FloatNode(0),
              b = new v3d.FloatNode(0),
              ifNode = new v3d.ColorNode(0x0000FF),
              elseNode = new v3d.ColorNode(0xFF0000);

            var cond = new v3d.CondNode(a, b, ifNode, elseNode, v3d.CondNode.EQUAL);

            mtl.color = cond;

            // GUI

            addGui('a', a.value, function(val) {

              a.value = val;

            }, false, 0, 1);

            addGui('b', b.value, function(val) {

              b.value = val;

            }, false, 0, 1);

            addGui('a condition b', {
              EQUAL: v3d.CondNode.EQUAL,
              NOT_EQUAL: v3d.CondNode.NOT_EQUAL,
              GREATER: v3d.CondNode.GREATER,
              GREATER_EQUAL: v3d.CondNode.GREATER_EQUAL,
              LESS: v3d.CondNode.LESS,
              LESS_EQUAL: v3d.CondNode.LESS_EQUAL
            }, function(val) {

              cond.op = val;

              mtl.needsUpdate = true;

            });

            addGui('if color', ifNode.value.getHex(), function(val) {

              ifNode.value.setHex(val);

            }, true);

            addGui('else color', elseNode.value.getHex(), function(val) {

              elseNode.value.setHex(val);

            }, true);

            break;

          case 'rtt':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var uvTransform = new v3d.UVTransformNode(),
              checker = new v3d.CheckerNode(uvTransform);

            uvTransform.setUvTransform(0, 0, 2, 2, 0);

            var rtt = new v3d.RTTNode(512, 512, checker),
              bumpMap = new v3d.BumpMapNode(rtt);

            bumpMap.scale.value = .1;

            mtl.color = checker;
            mtl.normal = bumpMap;

            // GUI

            addGui('bump', bumpMap.scale.value, function(val) {

              bumpMap.scale.value = val;

            }, false, - .5, .5);

            addGui('scale', 2, function(val) {

              uvTransform.setUvTransform(0, 0, val, val, 0);

            }, false, 0, 8);

            addGui('ignoreColor', false, function(val) {

              mtl.color = val ? new v3d.ColorNode(0xFFFFFF) : checker;

              mtl.needsUpdate = true;

            });

            break;

          case 'temporal-blur':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var texture = new v3d.TextureNode(getTexture("brick"));

            var rttStore = new v3d.RTTNode(512, 512, texture);
            var blur = new v3d.BlurNode(rttStore);

            var timer = new v3d.TimerNode(.01, v3d.TimerNode.LOCAL);

            var color = new v3d.Math3Node(
              rttStore,
              blur,
              new v3d.FloatNode(.6),
              v3d.Math3Node.MIX
            );

            blur.horizontal = blur.vertical = timer;

            var rttSave = new v3d.RTTNode(512, 512, color);
            rttSave.saveTo = rttStore;

            mtl.color = rttSave;

            // GUI

            addGui('click to reset', false, function() {

              // render a single time

              rttStore.render = true;

              // reset time blur

              timer.value = 0;

            });

            break;

          case 'readonly':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            mtl.color = new v3d.ColorNode(0xFFFFFF);
            mtl.specular = new v3d.FloatNode(.5);
            mtl.shininess = new v3d.FloatNode(15);

            // not use "uniform" input (for optimization)
            // instead use explicit declaration, for example:
            // vec3(1.0, 1.0, 1.0) instead "uniform vec3"
            // if readonly is true not allow change the value after build the shader material
            mtl.color.readonly = mtl.specular.readonly = mtl.shininess.readonly = true;

            break;

          case 'triangle-blur':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var delta = new v3d.Vector2Node(.5, .25);
            var alpha = new v3d.FloatNode(1);

            var blurtexture = new v3d.FunctionNode([
              // Reference: TriangleBlurShader.js
              "vec4 blurtexture(sampler2D texture, vec2 uv, vec2 delta) {",
              "  vec4 color = vec4(0.0);",
              "  float total = 0.0;",
              // randomize the lookup values to hide the fixed number of samples
              "  float offset = rand(uv);",
              "  for (float t = -BLUR_ITERATIONS; t <= BLUR_ITERATIONS; t ++) {",
              "    float percent = (t + offset - 0.5) / BLUR_ITERATIONS;",
              "    float weight = 1.0 - abs(percent);",
              "    color += texture2D(texture, uv + delta * percent) * weight;",
              "    total += weight;",
              "  }",
              "  return color / total;",
              "}"
            ].join("\n"), [new v3d.ConstNode("float BLUR_ITERATIONS 10.0")]);

            var blurredTexture = new v3d.FunctionCallNode(blurtexture, {
              texture: new v3d.TextureNode(getTexture("brick")),
              delta: delta,
              uv: new v3d.UVNode()
            });

            var color = new v3d.Math3Node(
              new v3d.TextureNode(getTexture("brick")),
              blurredTexture,
              alpha,
              v3d.Math3Node.MIX
            );

            mtl.color = color;

            // GUI

            addGui('alpha', alpha.value, function(val) {

              alpha.value = val;

            }, false, 0, 1);

            addGui('deltaX', delta.x, function(val) {

              delta.x = val;

            }, false, 0, 1);

            addGui('deltaY', delta.x, function(val) {

              delta.y = val;

            }, false, 0, 1);

            break;

          case 'triplanar-mapping':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var scale = new v3d.FloatNode(.02);

            var triplanarMapping = new v3d.FunctionNode([
              // Reference: https://github.com/keijiro/StandardTriplanar
              "vec4 triplanar_mapping(sampler2D texture, vec3 normal, vec3 position, float scale) {",

              // Blending factor of triplanar mapping
              "  vec3 bf = normalize(abs(normal));", 
              "  bf /= dot(bf, vec3(1.0));",

              // Triplanar mapping
              "  vec2 tx = position.yz * scale;",
              "  vec2 ty = position.zx * scale;",
              "  vec2 tz = position.xy * scale;",

              // Base color
              "  vec4 cx = texture2D(texture, tx) * bf.x;",
              "  vec4 cy = texture2D(texture, ty) * bf.y;",
              "  vec4 cz = texture2D(texture, tz) * bf.z;",

              "  return cx + cy + cz;",

              "}"
            ].join("\n"));

            var triplanarMappingTexture = new v3d.FunctionCallNode(triplanarMapping, {
              texture: new v3d.TextureNode(getTexture("brick")),
              normal: new v3d.NormalNode(v3d.NormalNode.WORLD),
              position: new v3d.PositionNode(v3d.PositionNode.WORLD),
              scale: scale,
            });

            mtl.color = triplanarMappingTexture;

            // GUI

            addGui('scale', scale.value, function(val) {

              scale.value = val;

            }, false, 0.001, .1);

            break;

          case 'firefly':

            // MATERIAL

            mtl = new v3d.PhongNodeMaterial();

            var time = new v3d.TimerNode();
            var speed = new v3d.FloatNode(.5);

            var color = new v3d.ColorNode(0x98ff00);

            var timeSpeed = new v3d.OperatorNode(
              time,
              speed,
              v3d.OperatorNode.MUL
            );

            var sinCycleInSecs = new v3d.OperatorNode(
              timeSpeed,
              new v3d.ConstNode(v3d.ConstNode.PI2),
              v3d.OperatorNode.MUL
            );

            var cycle = new v3d.Math1Node(sinCycleInSecs, v3d.Math1Node.SIN);

            var cycleColor = new v3d.OperatorNode(
              cycle,
              color,
              v3d.OperatorNode.MUL
            );

            var cos = new v3d.Math1Node(cycleColor, v3d.Math1Node.SIN);

            mtl.color = new v3d.ColorNode(0);
            mtl.emissive = cos;

            // GUI

            addGui('speed', speed.value, function(val) {

              speed.value = val;

            }, false, 0, 3);

            break;

          case 'sss':
          case 'translucent':

            // DISTANCE FORMULA

            var modelPos = new v3d.Vector3Node();

            var viewPos = new v3d.PositionNode(v3d.PositionNode.VIEW);
            var cameraPosition = new v3d.CameraNode(v3d.CameraNode.POSITION);

            var cameraDistance = new v3d.Math2Node(
              modelPos,
              cameraPosition,
              v3d.Math2Node.DISTANCE
            );

            var viewPosZ = new v3d.SwitchNode(viewPos, 'z');

            var distance = new v3d.OperatorNode(
              cameraDistance,
              viewPosZ,
              v3d.OperatorNode.SUB
            );

            var distanceRadius = new v3d.OperatorNode(
              distance,
              new v3d.FloatNode(70),
              v3d.OperatorNode.ADD
            );

            var objectDepth = new v3d.Math3Node(
              distanceRadius,
              new v3d.FloatNode(0),
              new v3d.FloatNode(50),
              v3d.Math3Node.SMOOTHSTEP
            );

            // RTT (get back distance)

            rtTexture = new v3d.WebGLRenderTarget(window.innerWidth, window.innerHeight, { minFilter: v3d.LinearFilter, magFilter: v3d.NearestFilter, format: v3d.RGBFormat });

            library[rtTexture.texture.uuid] = rtTexture.texture;

            var distanceMtl = new v3d.PhongNodeMaterial();
            distanceMtl.environment = objectDepth;
            distanceMtl.side = v3d.BackSide;

            rtMaterial = distanceMtl;

            // MATERIAL

            mtl = new v3d.StandardNodeMaterial();

            var backSideDepth = new v3d.TextureNode(rtTexture.texture, new v3d.ScreenUVNode());

            var difference = new v3d.OperatorNode(
              objectDepth,
              backSideDepth,
              v3d.OperatorNode.SUB
            );

            var sss = new v3d.Math3Node(
              new v3d.FloatNode(- .1),
              new v3d.FloatNode(.5),
              difference,
              v3d.Math3Node.SMOOTHSTEP
            );

            var sssAlpha = new v3d.Math1Node(sss, v3d.Math1Node.SAT);

            var frontColor, backColor;

            if (name == 'sss') {

              var sssOut = new v3d.Math2Node(
                objectDepth,
                sssAlpha,
                v3d.Math2Node.MIN
              );

              frontColor = new v3d.ColorNode(0xd4cfbb);
              backColor = new v3d.ColorNode(0xd04327);

              var color = new v3d.Math3Node(
                backColor,
                frontColor,
                sssOut,
                v3d.Math3Node.MIX
              );

              var light = new v3d.OperatorNode(
                new v3d.LightNode(),
                color,
                v3d.OperatorNode.ADD
              );

              mtl.color = frontColor;
              mtl.roughness = new v3d.FloatNode(.1);
              mtl.metalness = new v3d.FloatNode(.5);

              mtl.light = light;
              mtl.environment = color;

            } else {

              frontColor = new v3d.ColorNode(0xd04327);
              backColor = new v3d.ColorNode(0x1a0e14);

              var color = new v3d.Math3Node(
                frontColor,
                backColor,
                sssAlpha,
                v3d.Math3Node.MIX
              );

              var light = new v3d.OperatorNode(
                new v3d.LightNode(),
                color,
                v3d.OperatorNode.ADD
              );

              mtl.color = new v3d.ColorNode(0xffffff);
              mtl.roughness = new v3d.FloatNode(.1);
              mtl.metalness = new v3d.FloatNode(.5);

              mtl.light = light;
              mtl.environment = color;

            }

            // GUI

            addGui('frontColor', frontColor.value.getHex(), function(val) {

              frontColor.value.setHex(val);

            }, true);

            addGui('backColor', backColor.value.getHex(), function(val) {

              backColor.value.setHex(val);

            }, true);

            addGui('area', sss.b.value, function(val) {

              sss.b.value = val;

            }, false, 0, 1);

            break;

        }

        // set material

        mtl.side = v3d.DoubleSide;

        mesh.material = mtl;

      }

      function onWindowResize() {

        var width = window.innerWidth, height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);

        if (rtTexture) rtTexture.setSize(width, height);

      }

      document.getElementById('serialize').addEventListener('click', function() {

        if (serialized) reset();
        else serialize();

        serialized = ! serialized;

      });

      function reset() {

        updateMaterial();

        // gui

        var div = document.getElementById('serialize');
        div.textContent = "Serialize and apply";

      }

      function serialize() {

        var json = mesh.material.toJSON();

        // replace uuid to url (facilitates the load of textures using url otherside uuid) e.g:

        var cloud = getTexture("cloud");

        v3d.NodeMaterialLoaderUtils.replaceUUID(json, cloud, "cloud");

        library["cloud"] = cloud;

        // --

        var jsonStr = JSON.stringify(json);

        console.log(jsonStr);

        var loader = new v3d.NodeMaterialLoader(null, library),
          material = loader.parse(json);

        mesh.material.dispose();

        mesh.material = material;

        // gui

        var div = document.getElementById('serialize');
        div.textContent = "Click to reset - JSON Generate: " + (jsonStr.length / 1024).toFixed(3) + "kB";

        if (gui) gui.destroy();

        gui = null;

      }

      function animate() {

        var delta = clock.getDelta();

        if (move) {

          var time = Date.now() * 0.005;

          mesh.position.z = Math.cos(time) * 10;
          mesh.position.y = Math.sin(time) * 10;

        } else {

          mesh.position.z = mesh.position.y = 0;

        }

        //mesh.rotation.z += .01;

        // update material animation and/or gpu calcs (pre-renderer)

        frame.update(delta).setRenderer(renderer);

        if (mesh.material instanceof v3d.NodeMaterial) {

          frame.updateNode(mesh.material);

        }

        // render to texture for sss/translucent material only

        if (rtTexture) {

          scene.overrideMaterial = rtMaterial;

          renderer.render(scene, camera, rtTexture, true);

          scene.overrideMaterial = null;

        }

        renderer.render(scene, camera);

        requestAnimationFrame(animate);

      }

    </script>

  </body>
</html>
